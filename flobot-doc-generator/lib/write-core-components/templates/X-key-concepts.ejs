---
date: 2016-03-09T00:11:02+01:00
title: Key Concepts
weight: 10
---


## Flows

__Everything in FlobotJS is built around flows: definitions of real-world business processes.__

- An organisation is likely to contain hundreds of business processes, of all shapes-and-sizes. Flows can underpin something as simple as searching for a document through to complex multi-team undertakings.

- Flows may involve people from multiple teams or require no human input at all. It's likely an employee's role will require interaction with several flows - but probably not all of them.

- Flows play nicely with industry representations such as [State Diagrams](https://en.wikipedia.org/wiki/State_diagram), [Activity Diagrams](https://en.wikipedia.org/wiki/Activity_diagram) and [Business Process Diagrams](http://www.bpmn.org/).

### The booking-someone-sick flow

![Simple state diagram for booking-someone-sick](/images/simple-flow.png)

- In the diagram above, the operator has been granted access to this particular flow and can _instigate_ it 

- The _initial_ step is for the operator to complete a form containing all the details of the sickness.

- Once the form has been completed, an email is sent to the employee's manager containing a summary about the absence.

- What happens next is dependent on whether the absence will reduce staffing below some critical level. Either things are fine and the flow can move to the final step or the Operations Room will be alerted to the staffing shortfall. 

- And to finish, the employee will have a new entry added to their sickness record.
 

## States

Each of the circles in the previous diagram are known as __States__.  More accurately, a FlobotJS flow contains all the necessary information to assemble a [Finite State Machine] (https://en.wikipedia.org/wiki/State_diagram) (__FSM__), that being:

- A list of possible states (an FSM can be in exactly one of a finite number of states at any given time)

- How states are connected together (along with any conditions that are required)

- Which is the _initial_ state (i.e. the state that is active when things first start)

FlobotJS offers a pool of different __State Classes__ from which flows can be constructed. It's possible to deliver a good chunk of back-office functionality with surprisingly few state classes.

For example, the state classes below should be enough to model large swathes of organisational data collection:
 
State class               | What does the state do?
------------------------- | -----------------------------------------------------------------------------------
`formFilling`             | Provides the details of a form for a human to complete. Things will wait in this state until some data is submitted
`saving-doc`              | Saves a document to a database (e.g. the data collected via a `formFilling` state)
`settingSearchIndex`      | Adds some details to a search index so that people can search and find it again later
`finding-one`             | Fetches a single document from a database
`deleting-one`            | Deletes a document from a database  
`deletingFromSearchIndex` | Removes details from a search index - so that it won't show-up in searches anymore
`sendingEmail`            | Generates and sends an email
`importing`               | Imports some data from CSV files or similar

- For a full list of states that are currently available out-of-the-box, please see the [State Classes](http://localhost:1313/state-classes/) section.  

## Flobots

At this point it _might_  be useful to think of things in terms of a railway network...

{{< note title="Analogy alert!" >}}
  
- __Flows__ can be seen as the railway track - connecting states together in a very controlled way

- __States__ can be seen as the railway stations - they're reached by travelling around flows. Journeys start at the _initial_ state.

- __Flobots__ therefore can be seen as individual trains as they transition from state-to-state. A single flow can have any number of Flobots making their way around it.

{{< /note >}}

Flobots can be persisted as a simple document so that they survive server restarts.
To help better understand what's This is an example of what might be persisted for a Flobot travelling around the __booking-someone-sick__ flow from earlier:

``` JSON
{ 
    "_id" : "586e42ade923c119c4a4a85b", 
    "createdAt" : "2017-01-05T12:57:17.701+0000",
    "userId" : "john.doe@flobotjs.io", 
    "status" : "running", 
    "flowId" : "booking-someone-sick", 
    "stateId" : "notifyingOperationsRoom", 
    "stateEnterTime" : "2017-01-05T12:57:17.686+0000", 
    "ctx" : {
        "formData" : {
            "employeeNumber": 372711,
            "likelyReturnDate": "2017-01-07T09:00:00.000+0000",
            "sicknessCode": "hangover"
        }
    }
}
```

The various properties in this example document are described in the table below:

Property         | Description
---------------- | ---------------------------------
`_id`            | Uniquely identifies a Flobot
`createdAt`      | When the Flobot was first instigated
`userId`         | If the Flobot was instigated by a human, then this is the userId of that person 
`status`         | Always one of `starting`, `running`, `waitingForHumanInput` or `finished`
`flowId`         | Identifies which flow this Flobot is travelling around
`stateId`        | Indicates the state that this Flobot is currently in
`stateEnterTime` | The timestamp of when the Flobot entered its current state
`ctx`            | This is a simple key/value store that's unique to each Flobot. In analogy terms, a good place to store the number of passengers on this particular train. This __context__ is available to all states to read-from/write-to as they require. In this way, inter-state communication is possible - but within context of each ~~train~~ Flobot. 

## Blueprints

On their own, flow definitions aren't enough... for everything to spark, states need to be fed things like data models, form layouts, images, custom logic, templates etc.
This is where Flobot __Blueprints__ come in. The actual content of a Blueprint is beyond the scope of this article, but just to say Blueprints themselves are nothing special, just a simple folder structure: 

![Simple blueprint structure showing a root directory and folders such as 'flows', 'forms' and 'models'](/images/blueprint-dir.png)

Given an organisation could potentially attract hundreds of flows, blueprints can logically group together related flows (perhaps into teams or functional areas) to help make things more manageable.
Blueprints also help with versioning, collaboration (on Github or similar) and interoperability. 

The Flobot framework can load any number of blueprints at startup, potentially serving all back-office functionality from a single server.

## Plugins

Flobot takes a batteries-included approach and hopefully ships with enough [State Classes](#states) to cover-off most of the the duller business processes out there. To help try and keep things minimal and manageable Flobot employs a __plugin__ architecture.
A Flobot plugin extends the core framework with related State Classes (along with other internal components required to run them).

- Please see the [list of core plugins](/core-components/#list-of-plugins) to get a feel for what plugins are about

Flobot's current library of state classes is certainly far from exhaustive and organisations will undoubtedly have specialist requirements of their own.
Thankfully it's really straightforward to write new plugins for Flobot to add missing capabilities.





 
 
